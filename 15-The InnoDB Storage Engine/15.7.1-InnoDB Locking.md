# 15.7.1 InnoDB Locking

## 共享锁(Shared Lock)和排他锁(Exclusive Locks)

InnoDB实现标准的行级锁定，其中有两种类型的锁：共享（S）锁和排他（X）锁。

- 共享（S）锁允许持有该锁的事务读取一行。
- 排他（X）锁允许持有该锁的事务更新或删除行。

如果事务T1在行r上持有共享（S）锁，那么来自某些不同事务T2的对行r的锁请求将按以下方式处理：

- T2对S锁的请求可以立即获得批准。 结果，T1和T2都在r上保持了S锁。
- T2不能立即授予X锁请求。

如果事务T1在行r上持有排他（X）锁，则不能立即批准某个不同事务T2对r上任一类型的锁的请求。
相反，事务T2必须等待事务T1释放对行r的锁定。

## 意向锁(Intention Locks)

InnoDB支持多种粒度锁定，**允许行锁和表锁并存**。
例如，诸如LOCK TABLES ... WRITE之类的语句对指定表采用排他锁（X锁）。
为了使在多个粒度级别上的锁定变得切实可行，InnoDB使用了意图锁定。
意向锁是**表级锁**，指示事务稍后对表中的行需要哪种类型的锁（共享锁或排他锁）。 有两种类型的意图锁：

- 意向共享锁（IS）表示事务打算对表中的各个行设置共享锁。
- 意向排他锁（IX）表示事务打算对表中的各个行设置排他锁。

例如，SELECT ... FOR SHARE设置IS锁，而SELECT ... FOR UPDATE设置IX锁。
意图锁定协议如下：

- 在事务可以获取表中某行的共享锁之前，它必须首先获取该表中的IS锁或更强的锁。
- 在事务可以获取表中某行的排它锁之前，它必须首先获取该表中的IX锁。

表级锁类型的兼容性汇总如下:

![](intention-locks-compatible.png)

如果锁与现有锁兼容，则将其授予请求的事务，但如果与现有锁冲突，则不授予该请求。事务等待直到冲突的现有锁被释放。
如果锁定请求与现有锁定发生冲突，并且由于可能导致死锁而无法被授予，则会发生错误。

意向锁除了全表请求（例如LOCK TABLES ... WRITE）外，不阻止任何其他内容。
意图锁定的主要目的是表明某人正在锁定一行或打算锁定表中的一行。

意向锁的事务数据在SHOW ENGINE INNODB STATUS和InnoDB监视器输出中看起来类似于以下内容：
```
TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
```

## 记录锁(Record Locks)

记录锁是**对索引记录的锁定**。
例如`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;`
防止任何其他事务插入，更新或删除t.c1值为10的行。

记录锁始终锁定索引记录，即使没有定义索引的表也是如此。
对于这种情况，**InnoDB创建一个隐藏的聚集索引**并将该索引用于记录锁定。
请参见第15.6.2.1节“聚集索引和二级索引”。

记录锁的事务数据在SHOW ENGINE INNODB STATUS和InnoDB监视器输出中看起来类似于以下内容：
```
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
```

## 间隙锁(Gap Locks)

间隙锁定是对索引记录之间的间隙的锁定，或者是对第一个索引记录之前或最后一个索引记录之后的间隙的锁定。
例如`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;`
防止其他事务将值15插入到t.c1列中，无论该列中是否已有这样的值，因为该范围中所有现有值之间的间隙是锁定的。

间隙可能跨越单个索引值，多个索引值，甚至为空。
间隙锁是性能和并发性之间权衡的一部分，并且在某些事务隔离级别而非其他级别中使用。

对于使用唯一索引来锁定唯一行来锁定行的语句，不需要间隙锁定。
（这不包括搜索条件仅包含多列唯一索引的某些列的情况；在这种情况下，会发生间隙锁定。）
例如，如果id列具有唯一索引，则以下语句仅使用ID值为100的行的索引记录锁，其他会话是否在前面的间隙中插入行都没有关系：
```
SELECT * FROM child WHERE id = 100;
```

如果id未建立索引或索引不唯一，则该语句会锁定前面的间隙。

在这里还值得注意的是，可以通过不同的事务将冲突的锁保持在间隙上。
例如，事务A可以在间隙上保留一个共享的间隙锁（间隙S锁），而事务B可以在同一间隙上保留排他的间隙锁（间隙X锁）。
允许冲突的间隙锁的原因是，如果从索引中清除记录，则必须合并由不同事务保留在记录上的间隙锁.

InnoDB的间隙锁是“纯粹的抑制性的”，这意味着它们的唯一目的是**防止其他事务插入间隙**。
**间隙锁可以共存**。一个事务进行的间隙锁定不会阻止另一事务对相同的间隙进行间隙锁定。
共享间隙锁和排他间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。

间隙锁定可以被显式的禁用。如果将事务隔离级别更改为**READ COMMITTED**，则会发生这种情况。
在这种情况下，进行搜索和索引扫描时将禁用间隙锁定，并且间隙锁定仅用于外键约束检查和重复键检查。

使用READ COMMITTED隔离级别还有其他影响。MySQL评估WHERE条件后，将释放不匹配行的记录锁。
对于UPDATE语句，InnoDB进行“半一致”读取，以便将最新的提交版本返回给MySQL，以便MySQL可以确定行是否与UPDATE的WHERE条件匹配。

## 下一键锁(Next-Key Locks)

下一键锁定是索引记录上的记录锁和索引记录之前的间隙上的间隙锁的组合。

InnoDB执行行级锁定的方式是，当它搜索或扫描表索引时，会在遇到的索引记录上设置共享或互斥锁。因此，**行级锁实际上是索引记录锁**。
索引记录上的下一键锁定也会影响该索引记录之前的“间隙”。即下一键锁定是索引记录的记录锁加上索引记录之前的间隙上的间隙锁。
如果一个会话在索引中的记录R上具有共享或排他锁，则另一会话不能在索引顺序紧靠R之前的间隙中插入新的索引记录。

假定索引包含值10、11、13和20。此索引的可能的下一键锁定涵盖以下间隙：
```
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
```

对于最后一个时间间隔，next-key锁将间隙锁定在索引中的最大值上方，并且“超级”伪记录的值高于索引中实际的任何值。
最高不是真正的索引记录，因此，实际上下一键锁仅锁定跟随最大索引值的间隙。

**默认情况下，InnoDB以REPEATABLE READ事务隔离级别运行**。
在这种情况下，**InnoDB使用next-key锁定进行搜索和索引扫描，从而防止幻读**（请参见第15.7.4节“幻读”）。

下一键锁定的事务数据在SHOW ENGINE INNODB STATUS和InnoDB监视器输出中看起来类似于以下内容：
```
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` 
trx id 10080 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
```

## 插入意向锁(Insert Intention Locks)

插入意向锁是一种在行插入之前通过**INSERT操作**设置的**间隙锁**。
此锁发出插入意图的信号是，如果多个事务未插入间隙中的相同位置，则无需等待彼此插入的多个事务。
假设有索引记录，其值分别为4和7。单独的事务分别尝试插入值5和6，在获得插入行的排他锁之前，
每个事务都使用插入意图锁来锁定4和7之间的间隙，但不会互相阻塞，因为行是无冲突的。

## 自增锁(AUTO-INC Locks)

自增锁是一种特殊的**表级锁**，由插入到具有**AUTO_INCREMENT列**的表中的事务获取。
在最简单的情况下，如果一个事务正在向表中插入值，则任何其他事务都必须等待自己在该表中进行插入，以便第一个事务插入的行接收连续的主键值。

innodb_autoinc_lock_mode配置选项控制用于自动增量锁定的算法。
它使您可以选择如何在可预测的自动增量值序列与插入操作的最大并发性之间进行权衡。

有关更多信息，请参见第15.6.1.4节“ InnoDB中的AUTO_INCREMENT处理”。

## 空间索引的谓词锁(Predicate Locks for Spatial Indexes)

TODO

---
[原文]: https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html
